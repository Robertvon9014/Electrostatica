{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"M\u00e9todos Num\u00e9ricos para la Ecuaci\u00f3n de Laplace","text":"<p>En este proyeto se implementa y compara distintos m\u00e9todos num\u00e9ricos para resolver la ecuaci\u00f3n diferencial de Laplace en dos dimensiones, modelando  un capacitor ideal en una placa cuadrada 10 cm x 10 cm</p> <p>Incluimos las siguientes implementaciones: - M\u00e9todo de relajaci\u00f3n de Jacobi (Python) - M\u00e9todo de sobre-relajaci\u00f3n de Jacobi (Python) - M\u00e9todo de Gauss-Seidel (Python) - M\u00e9todo de Gauss-Seide (C++)</p> <p>El objetivo es compara la eficiencia y convergencia de los m\u00e9todos para la resoluci\u00f3n del potencial electroest\u00e1tito de una malla discreta, con condiciones de frontera internas simulando las placas del capacitos.</p> <p>Para m\u00e1s informaci\u00f3n consultar los apartados de explicaci\u00f3n y tutoriales.</p>"},{"location":"#contenidos","title":"Contenidos","text":"<ul> <li>Explicaci\u00f3n</li> <li>Tutoriales</li> </ul>"},{"location":"explanation/","title":"Explicaci\u00f3n de los M\u00e9todos Num\u00e9ricos","text":""},{"location":"explanation/#problema-fisico","title":"Problema f\u00edsico","text":"<p>Se resuelve la ecuaci\u00f3n de Laplace bidimensional para el potencial el\u00e9ctrico \\(\\phi(x,y)\\):</p> \\[ \\frac{\\partial^2 \\phi}{\\partial x^2} + \\frac{\\partial^2 \\phi}{\\partial y^2} = 0 \\] <p>Esta ecuaci\u00f3n nos permite describir el comportamiento de un potencial el\u00e9ctrico sobre una regi\u00f3n donde no existen cargas libres (es decir, en el  vac\u00edo o en materiales diel\u00e9ctricos).</p> <p>El dominio de este problema se encuentra  en una placa cuadrada de 10 cm \u00d7 10 cm, con dos barras internas que simulan las placas de un capacitor: - Una barra se localiza cerca del borde izquierdo y se mantiene con potencial constante positivo \\(V_p\\). - Otra barra se encuentra cerca del borde derecho con potencial negativo $ V_n$.</p> <p>La longitud de ambas barras es de 6 cm, y estan separadas a la misma distancia que su longitud, lo cual nos permite visualizar una configuraci\u00f3n sim\u00e9trica con respecto al eje horizontal.</p> <p>Condiciones del problema:   - En la condiciones del problemas donde no se especifique el potencial se asume que la condici\u00f3n de frontera tiene un valor inicial de cero, o      bien el potencial se actualiza iterativamente hasta converger.</p>"},{"location":"explanation/#metodos-implementados","title":"M\u00e9todos implementados","text":""},{"location":"explanation/#1-metodo-de-relajacion-de-jacobi","title":"1. M\u00e9todo de relajaci\u00f3n de Jacobi","text":"<p>Este m\u00e9todo itera actualizando el potencial en cada punto de la malla usando el promedio de sus vecinos en la iteraci\u00f3n anterior, manteniendo fijas las condiciones de frontera.</p> <p>La idea principal de este m\u00e9todo es que se actualiza el valor del potencial el\u00e9ctrico \\(\\phi(x,y)\\) en cada punto de la grilla como el promedio de los valores de sus vecinos adyacentes(arriba, abajo, izquierda, derecha) que se agarran de los datos iterativos anteriores, mientras mantenemos fijas las condiciones de frontera.</p> <p>Esto se repite hasta que hayamos alcanzado una diferencia m\u00e1xima entre dos iteraciones consecutivas, es lo que llamamos \"el delta\", y que este sea menor que una tolerancia escogida. Lo que nos indicar\u00e1 que hemos alcanzado la convergencia.</p> <ul> <li>Es sencillo pero convergencia lenta.</li> <li>Requiere dos matrices para mantener valores antiguos y nuevos.</li> </ul>"},{"location":"explanation/#2-metodo-de-sobre-relajacion-de-jacobi-jacobi-modificado","title":"2. M\u00e9todo de sobre-relajaci\u00f3n de Jacobi (Jacobi modificado)","text":"<p>Se aplica un factor de sobre-relajaci\u00f3n \\(\\omega\\) para acelerar la convergencia, mezclando el valor nuevo calculado con el anterior:</p> \\[ \\phi'(x, y) = (1+\\omega)\\left[\\frac{\\phi(x+a, y) + \\phi(x-a, y) + \\phi(x, y+a) + \\phi(x, y-a)}4\\right] - \\omega \\phi (x,y). \\] <ul> <li>Acelera la convergencia respecto al Jacobi est\u00e1ndar.</li> <li>Requiere ajuste del par\u00e1metro \\(\\omega\\) para optimizar rendimiento.</li> </ul>"},{"location":"explanation/#3-metodo-de-gauss-seidel","title":"3. M\u00e9todo de Gauss-Seidel","text":"<p>En este m\u00e9todo, la actualizaci\u00f3n del potencial en cada punto usa los valores m\u00e1s recientes disponibles (actualizados durante la misma iteraci\u00f3n), mejorando la velocidad de convergencia frente a Jacobi.</p> <ul> <li>Solo se necesita una matriz.</li> <li>Mejor convergencia en menos iteraciones.</li> </ul>"},{"location":"explanation/#4-metodo-de-gauss-seidel-en-c","title":"4. M\u00e9todo de Gauss-Seidel en C++","text":"<p>Implementaci\u00f3n equivalente al m\u00e9todo de Gauss-Seidel en Python, pero usando C++ con <code>std::vector</code> y <code>std::tuple</code>.</p> <ul> <li>Permite una posible extensi\u00f3n para paralelizaci\u00f3n.</li> <li>Mejora en eficiencia y manejo de memoria para casos grandes.</li> </ul>"},{"location":"explanation/#condiciones-de-frontera-y-configuracion-de-la-grilla","title":"Condiciones de frontera y configuraci\u00f3n de la grilla","text":"<ul> <li>La placa se discretiza en una malla de \\((M+1) \\times (M+1)\\) puntos.</li> <li>Dos barras verticales se colocan a 2 cm de cada borde lateral, con longitudes de 6 cm, y potenciales fijos \\(V_p\\) y \\(V_n\\).</li> <li>El resto de bordes y posiciones iniciales son 0.</li> </ul>"},{"location":"explanation/#convergencia-y-criterio-de-parada","title":"Convergencia y criterio de parada","text":"<p>La iteraci\u00f3n se detiene cuando la diferencia m\u00e1xima absoluta entre iteraciones consecutivas es menor que una tolerancia dada.</p>"},{"location":"explanation/#comparacion-y-resultados","title":"Comparaci\u00f3n y resultados","text":"<ul> <li>El m\u00e9todo de Gauss-Seidel converge m\u00e1s r\u00e1pido que Jacobi.</li> <li>La sobre-relajaci\u00f3n mejora a\u00fan m\u00e1s la velocidad si se escoge un \\(\\omega\\) adecuado (por ejemplo, 0.9).</li> <li>La implementaci\u00f3n en C++ es m\u00e1s eficiente y es base para paralelizaci\u00f3n futura.</li> </ul>"},{"location":"reference/","title":"Referencias","text":""},{"location":"reference/#metodo-de-relajacion-de-jacobi","title":"M\u00e9todo de relajaci\u00f3n de Jacobi","text":""},{"location":"reference/#src.jaccobi.jacobi_relaxation","title":"<code>jacobi_relaxation(L, M, V_p, V_n, tolerance)</code>","text":"<p>Resuelve el potencial el\u00e9ctrico en una placa cuadrada usando el m\u00e9todo de relajaci\u00f3n de Jacobi.</p> <p>Se modela la regi\u00f3n cuadrada de tama\u00f1o <code>L x L</code>dividida en <code>M x M</code> puntos. Se tienen dos barras verticales que se colocan como condiciones de frontera internas: Una posee un potencial <code>V_p</code> y otra con <code>V_n</code>. La funci\u00f3n itera hasta que el cambio m\u00e1ximo entre iteraciones sea menor que la <code>tolerance</code>.</p> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>Tama\u00f1o f\u00edsico de la placa cuadrada (dado en cm).</p> required <code>M</code> <code>int</code> <p>N\u00famero de divisiones de la grilla (grilla de (M+1) x (M+1)).</p> required <code>V_p</code> <code>float</code> <p>Voltaje aplicado en la barra positiva.</p> required <code>V_n</code> <code>float</code> <p>Voltaje aplicado en la barra negativa.</p> required <code>tolerance</code> <code>float</code> <p>Tolerancia para el criterio de convergencia.</p> required <p>Returns:</p> Name Type Description <code>phi</code> <code>ndarray</code> <p>Matriz de 2 dimensiones con potenciales verticales dados por dos barras.</p> <code>its</code> <code>int</code> <p>N\u00famero de iteraciones realizadas.</p> <code>delta</code> <code>float</code> <p>Error m\u00e1ximo alcanzado en la \u00faltima iteraci\u00f3n.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; phi, its, error = jacobi_relaxation(10, 100, 1.0, -1.0, 1e-5)\n&gt;&gt;&gt; print(f\"Iteraciones: {its}, Error final: {error:.2e}\")\nIteraciones: 1794, Error final: 9.99e-06\n</code></pre> Source code in <code>src/jaccobi.py</code> <pre><code>def jacobi_relaxation(L, M, V_p, V_n, tolerance):\n    \"\"\"\n    Resuelve el potencial el\u00e9ctrico en una placa cuadrada usando el m\u00e9todo de relajaci\u00f3n de Jacobi.\n\n    Se modela la regi\u00f3n cuadrada de tama\u00f1o `L x L`dividida en `M x M` puntos.\n    Se tienen dos barras verticales que se colocan como condiciones de frontera internas:\n    Una posee un potencial `V_p` y otra con `V_n`. La funci\u00f3n itera hasta que el cambio\n    m\u00e1ximo entre iteraciones sea menor que la `tolerance`.\n\n    Args:\n        L (int): Tama\u00f1o f\u00edsico de la placa cuadrada (dado en cm).\n        M (int): N\u00famero de divisiones de la grilla (grilla de (M+1) x (M+1)).\n        V_p (float): Voltaje aplicado en la barra positiva.\n        V_n (float): Voltaje aplicado en la barra negativa.\n        tolerance (float): Tolerancia para el criterio de convergencia.\n\n    Returns:\n        phi (ndarray): Matriz de 2 dimensiones con potenciales verticales dados por dos barras.\n        its (int): N\u00famero de iteraciones realizadas.\n        delta (float): Error m\u00e1ximo alcanzado en la \u00faltima iteraci\u00f3n.\n\n    Examples:\n        &gt;&gt;&gt; phi, its, error = jacobi_relaxation(10, 100, 1.0, -1.0, 1e-5)\n        &gt;&gt;&gt; print(f\"Iteraciones: {its}, Error final: {error:.2e}\")\n        Iteraciones: 1794, Error final: 9.99e-06\n    \"\"\"\n    # Primero creamos los arreglos 2-dimensionales de la grilla\n    # Vamos a necesitar dos seg\u00fan la regla de Jacobi\n    # Note que usamos M+1, debido a que debemos contener la condici\u00f3n de frontera\n    # phi contiene inicialmente los valores iniciales. Vamos a utilizar ceros.\n    phi = np.zeros((M + 1, M + 1), dtype=float)\n    # Ahora tenemos que colocar la condici\u00f3n inicial.\n    # Recuerde accesos de listas en np.ndarray\n\n    # Validamos que M sea mayor a 10\n    if M &lt;= 10:\n        raise ValueError(\"El tama\u00f1o de la grilla (M) debe ser mayor a 10\")\n\n    # --- Calculamos la reposici\u00f3n dependiendo el tama\u00f1o de M\n    fil_start = int(M * 0.2) # 2 cm desde arriba\n    bar_len = int(M * 0.6)   # 6 cm longitud de la barra\n    fil_end = fil_start + bar_len\n\n    col_plus = int(M * 0.2)  # Voltaje positivo a 2 cm del borde izquierdo\n    col_neg = col_plus + bar_len # Voltaje Negativo a 2 cm del borde derecho\n\n    # Ahora tenemos que colocar la condici\u00f3n inicial.\n    # Recuerde accesos de listas en np.ndarray\n    phi[fil_start:fil_end, col_plus] = V_p  # Barra positiva\n    phi[fil_start:fil_end, col_neg] = V_n    # Barra negativa\n\n    # phiprime se necesita para la iteraci\u00f3n\n    phiprime = np.zeros((M + 1, M + 1), dtype=float)\n    # Iteraci\u00f3n de Jacobi\n    delta = 1.0\n    its = 0\n    while delta &gt; tolerance:\n        # Calculamos la iteraci\u00f3n\n        its += 1\n        for i in range(M + 1):\n            for j in range(M + 1):\n                # Condici\u00f3n de frontera\n                if j == col_plus and fil_start &lt;= i &lt;= fil_end or j == col_neg and fil_start &lt;= i &lt;= fil_end:\n                    phiprime[i, j] = phi[i,j]\n                elif i == 0 or i == M or j == 0 or j == M:\n                    phiprime[i, j] = phi[i, j]\n                # Iteraci\u00f3n principal\n                else:\n                # COMPLETE AQU\u00cd\n                    phiprime[i,j] = 0.25 * (phi[i + 1, j] + phi[i - 1, j] + phi[i, j + 1] + phi[i, j - 1])\n        # Calculamos la diferencia m\u00e1xima con respecto a los valores anteriores\n        delta = np.max(np.abs(phi - phiprime))\n        # Ahora intercambiamos los arreglos para la nueva iteraci\u00f3n\n        # El nuevo phi es el phiprime\n        temp = phi\n        phi = phiprime\n        # El nuevo phiprime es el phi viejo\n        phiprime = temp\n\n    return phi, its, delta\n</code></pre>"},{"location":"reference/#metodo-de-sobre-relajacion-de-jacobi","title":"M\u00e9todo de Sobre-relajaci\u00f3n de Jacobi","text":""},{"location":"reference/#src.jaccobi_modified.jacobi_modified","title":"<code>jacobi_modified(L, M, V_p, V_n, omega, tolerance)</code>","text":"<p>Aplicamos el m\u00e9todo de Jacobi modificado con sobre-relajaci\u00f3n para resolver el potencial el\u00e9ctrico en una placa cuadrada con condiciones de frontera internas.</p> <p>Se modela la regi\u00f3n cuadrada de tama\u00f1o <code>L x L</code>dividida en <code>M x M</code> puntos. Se tienen dos barras verticales que se colocan como condiciones de frontera internas: Una posee un potencial <code>V_p</code> y otra con <code>V_n</code>. Se actualiza iterativamente el potencial en el resto de la grilla usando un factor de sobre-relajaci\u00f3n <code>omega</code> para acelerar la convergencia.</p> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>Tama\u00f1o f\u00edsico de la placa cuadrada (dado en cm).</p> required <code>M</code> <code>int</code> <p>N\u00famero de divisiones de la grilla (grilla de (M+1) x (M+1)).</p> required <code>V_p</code> <code>float</code> <p>Voltaje aplicado en la barra positiva.</p> required <code>V_n</code> <code>float</code> <p>Voltaje aplicado en la barra negativa.</p> required <code>tolerance</code> <code>float</code> <p>Tolerancia para el criterio de convergencia.</p> required <p>Returns:</p> Name Type Description <code>phi</code> <code>ndarray</code> <p>Matriz de 2 dimensiones con potenciales verticales dados por dos barras.</p> <code>its</code> <code>int</code> <p>N\u00famero de iteraciones realizadas.</p> <code>delta</code> <code>float</code> <p>Error m\u00e1ximo alcanzado en la \u00faltima iteraci\u00f3n.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; phi, its, error = jacobi_modified(10, 100, 1.0, -1.0, 1e-5)\n&gt;&gt;&gt; print(f\"Iteraciones: {its}, Error final: {error:.2e}\")\nerror en la iteraci\u00f3n.\n</code></pre> Source code in <code>src/jaccobi_modified.py</code> <pre><code>def jacobi_modified(L, M, V_p, V_n, omega, tolerance):\n    \"\"\"\n    Aplicamos el m\u00e9todo de Jacobi modificado con sobre-relajaci\u00f3n para resolver\n    el potencial el\u00e9ctrico en una placa cuadrada con condiciones de frontera internas.\n\n    Se modela la regi\u00f3n cuadrada de tama\u00f1o `L x L`dividida en `M x M` puntos.\n    Se tienen dos barras verticales que se colocan como condiciones de frontera internas:\n    Una posee un potencial `V_p` y otra con `V_n`. Se actualiza iterativamente el potencial\n    en el resto de la grilla usando un factor de sobre-relajaci\u00f3n `omega` para acelerar la convergencia.\n\n    Args:\n        L (int): Tama\u00f1o f\u00edsico de la placa cuadrada (dado en cm).\n        M (int): N\u00famero de divisiones de la grilla (grilla de (M+1) x (M+1)).\n        V_p (float): Voltaje aplicado en la barra positiva.\n        V_n (float): Voltaje aplicado en la barra negativa.\n        tolerance (float): Tolerancia para el criterio de convergencia.\n\n    Returns:\n        phi (ndarray): Matriz de 2 dimensiones con potenciales verticales dados por dos barras.\n        its (int): N\u00famero de iteraciones realizadas.\n        delta (float): Error m\u00e1ximo alcanzado en la \u00faltima iteraci\u00f3n.\n\n    Examples:\n        &gt;&gt;&gt; phi, its, error = jacobi_modified(10, 100, 1.0, -1.0, 1e-5)\n        &gt;&gt;&gt; print(f\"Iteraciones: {its}, Error final: {error:.2e}\")\n        error en la iteraci\u00f3n.\n    \"\"\"\n    # Primero creamos los arreglos 2-dimensionales de la grilla\n    # Vamos a necesitar dos seg\u00fan la regla de Jacobi\n    # Note que usamos M+1, debido a que debemos contener la condici\u00f3n de frontera\n    # phi contiene inicialmente los valores iniciales. Vamos a utilizar ceros.\n    phi = np.zeros((M + 1, M + 1), dtype=float)\n\n    # Validamos que el tama\u00f1o M sea mayor a 10\n    if M &lt;= 10:\n        raise ValueError(\"El tama\u00f1o de la grilla (M) deber ser mayor a 10\")\n\n    # --- Calculamos la reposici\u00f3n dependiendo del valor de M\n    fil_start = int(0.2 * M) # 2 cm desde arriba\n    vol_len = int(0.6 * M)   # 6 cm longitud de la barra\n    fil_end = fil_start + vol_len\n\n    col_plus = int(0.2 * M)  # voltaje positivo a 2 cm del borde izquierdo\n    col_neg = col_plus + vol_len # Voltaje negativo a 2 cm del borde derecho\n\n    # Ahora tenemos que colocar la condici\u00f3n inicial.\n    # Recuerde accesos de listas en np.ndarray\n    phi[fil_start:fil_end, col_plus] = V_p\n    phi[fil_start:fil_end, col_neg] = V_n\n    # phiprime se necesita para la iteraci\u00f3n\n    phiprime = np.zeros((M + 1, M + 1), dtype=float)\n    # Iteraci\u00f3n de Jacobi\n    delta = 1.0\n    its = 0\n    while delta &gt; tolerance:\n        # Calculamos la iteraci\u00f3n\n        its += 1\n        for i in range(M + 1):\n            for j in range(M + 1):\n                if j == col_plus and fil_start &lt;= i &lt;= fil_end or j == col_neg and fil_start &lt;= i &lt;= fil_end:\n                    phiprime[i, j] = phi[i, j]\n                # Condici\u00f3n de frontera\n                elif i == 0 or i == M or j == 0 or j == M:\n                    phiprime[i, j] = phi[i, j]\n                # Iteraci\u00f3n principal\n                else:\n                # COMPLETE AQU\u00cd\n                    phiprime[i,j] = (1 + omega) * (0.25 * (phi[i + 1, j] + phi[i - 1, j] + phi[i, j + 1] + phi[i, j - 1])) - (omega * phi[i,j])\n        # Calculamos la diferencia m\u00e1xima con respecto a los valores anteriores\n        delta = np.max(np.abs(phi - phiprime))\n        # Ahora intercambiamos los arreglos para la nueva iteraci\u00f3n\n        # El nuevo phi es el phiprime\n        temp = phi\n        phi = phiprime\n        # El nuevo phiprime es el phi viejo\n        phiprime = temp\n    return phi, its, delta\n</code></pre>"},{"location":"reference/#metodo-de-gauss-seidel","title":"M\u00e9todo de Gauss-seidel","text":""},{"location":"reference/#src.gauss_seidel.gauss_seidel","title":"<code>gauss_seidel(L, M, V_p, V_n, tolerance)</code>","text":"<p>Resuelve el potencial el\u00e9ctrico en una placa cuadrada usando el m\u00e9todo de Gauss-seidel.</p> <p>Se modela la regi\u00f3n cuadrada de tama\u00f1o <code>L x L</code>dividida en <code>M x M</code> puntos. Se tienen dos barras verticales que se colocan como condiciones de frontera internas: Una posee un potencial <code>V_p</code> y otra con <code>V_n</code>. La funci\u00f3n itera hasta que el cambio m\u00e1ximo entre iteraciones sea menor que la <code>tolerance</code>.</p> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>Tama\u00f1o f\u00edsico de la placa cuadrada (dado en cm).</p> required <code>M</code> <code>int</code> <p>N\u00famero de divisiones de la grilla (grilla de (M+1) x (M+1)).</p> required <code>V_p</code> <code>float</code> <p>Voltaje aplicado en la barra positiva.</p> required <code>V_n</code> <code>float</code> <p>Voltaje aplicado en la barra negativa.</p> required <code>tolerance</code> <code>float</code> <p>Tolerancia para el criterio de convergencia.</p> required <p>Returns:</p> Name Type Description <code>phi</code> <code>ndarray</code> <p>Matriz de 2 dimensiones con potenciales verticales dados por dos barras.</p> <code>its</code> <code>int</code> <p>N\u00famero de iteraciones realizadas.</p> <code>delta</code> <code>float</code> <p>Error m\u00e1ximo alcanzado en la \u00faltima iteraci\u00f3n.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; phi, its, error = jacobi_relaxation(10, 100, 1.0, -1.0, 1e-5)\n&gt;&gt;&gt; print(f\"Convergencia alcanzada en {itertions} iteraciones con error de {error:.2e}\")\nConvergencia alcanzada en 1125 iteraciones con error de 9.97e-06\n</code></pre> Source code in <code>src/gauss_seidel.py</code> <pre><code>def gauss_seidel(L, M, V_p, V_n, tolerance):\n    \"\"\"\n    Resuelve el potencial el\u00e9ctrico en una placa cuadrada usando el m\u00e9todo de Gauss-seidel.\n\n    Se modela la regi\u00f3n cuadrada de tama\u00f1o `L x L`dividida en `M x M` puntos.\n    Se tienen dos barras verticales que se colocan como condiciones de frontera internas:\n    Una posee un potencial `V_p` y otra con `V_n`. La funci\u00f3n itera hasta que el cambio\n    m\u00e1ximo entre iteraciones sea menor que la `tolerance`.\n\n    Args:\n        L (int): Tama\u00f1o f\u00edsico de la placa cuadrada (dado en cm).\n        M (int): N\u00famero de divisiones de la grilla (grilla de (M+1) x (M+1)).\n        V_p (float): Voltaje aplicado en la barra positiva.\n        V_n (float): Voltaje aplicado en la barra negativa.\n        tolerance (float): Tolerancia para el criterio de convergencia.\n\n    Returns:\n        phi (ndarray): Matriz de 2 dimensiones con potenciales verticales dados por dos barras.\n        its (int): N\u00famero de iteraciones realizadas.\n        delta (float): Error m\u00e1ximo alcanzado en la \u00faltima iteraci\u00f3n.\n\n    Examples:\n        &gt;&gt;&gt; phi, its, error = jacobi_relaxation(10, 100, 1.0, -1.0, 1e-5)\n        &gt;&gt;&gt; print(f\"Convergencia alcanzada en {itertions} iteraciones con error de {error:.2e}\")\n        Convergencia alcanzada en 1125 iteraciones con error de 9.97e-06\n    \"\"\"\n    # Primero creamos el arreglo 2-dimensionales de la grilla\n    # Note que usamos M+1, debido a que debemos contener la condici\u00f3n de frontera\n    # phi contiene inicialmente los valores iniciales. Vamos a utilizar ceros.\n    phi = np.zeros((M + 1, M + 1), dtype=float)\n\n    # Validamos que M sea mayor que 10\n    if M &lt;= 10:\n        raise ValueError(\"El tama\u00f1o de la grila (M) debe ser mayor a 10\")\n\n    # --- Calculamos la reposici\u00f3n dependiendo del valor de M\n    fil_start = int(M * 0.2) # 2 cm desde arriba\n    vol_len = int(M * 0.6)   # 6 cm longitud de la barra\n    fil_end = fil_start + vol_len\n\n    col_plus = int(M * 0.2)  # voltaje positivo a 2 cm del borde izquierdo\n    col_neg = col_plus + vol_len # Voltaje negativo a 2 cm del borde derecho\n\n    # Ahora tenemos que colocar la condici\u00f3n inicial.\n    # Recuerde accesos de listas en np.ndarray\n    phi[fil_start:fil_end, col_plus] = V_p\n    phi[fil_start:fil_end, col_neg] = V_n\n    # Vamos a guardar una copia para evaluar el error\n    phi_copy = phi.copy()\n    # Iteraci\u00f3n de Gauss-Seidel\n    delta = 1.0\n    its = 0\n    while delta &gt; tolerance:\n        # Calculamos la iteraci\u00f3n\n        its += 1\n        for i in range(1, M):\n            for j in range(1, M):\n                # Condici\u00f3n de frontera\n                # En este caso, en la frontera los valores no se modifican\n                if fil_start &lt;= i &lt;= fil_end and (j == col_plus or j == col_neg):\n                    continue\n                # Iteraci\u00f3n principal\n                else:\n                    # COMPLETE AQU\u00cd\n                    phi[i,j] = 0.25 * (phi[i + 1, j] + phi[i - 1, j] + phi[i, j + 1] + phi[i, j - 1] )\n        # Calculamos la diferencia m\u00e1xima con respecto a los valores anteriores\n        delta = np.max(np.abs(phi - phi_copy))\n        # Copiamos los valores de la nueva iteraci\u00f3n\n        phi_copy = phi.copy()\n\n    return phi, its, delta\n</code></pre>"},{"location":"tutorials/","title":"Tutorial","text":"<p>En esta parte nos centraremos en un efonque orientado al aprendizaje. Aprenderemos como instalar las bibliotecas a utilizar y como implementar el m\u00e9todo de relajacion, sobre-relajacion de Jacobi, adem\u00e1s de implementar el m\u00e9todo de Gauss-Seidel en Python y en C++.</p>"},{"location":"tutorials/#requisitos-previos","title":"Requisitos previos","text":"<p>Antes de comenzar necesitamos tener instalado la siguiente biblioteca en nuestro entorno de python: <pre><code>pip instal numpy\npip install matplotlib\n</code></pre></p>"},{"location":"tutorials/#paso-1-configuramos-el-entorno","title":"Paso 1: Configuramos el entorno","text":"<p>Abrimos el editor de c\u00f3digo <code>vim</code> y creamor el nuevo archivo de python. Por ejemplo, lo llamamos jacobi.py</p>"},{"location":"tutorials/#paso-2-importamos-bibliotecas","title":"Paso 2: Importamos bibliotecas","text":"<p>Comenzamos importando las bibliotecas requeridas para el c\u00f3digo</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\n</code></pre>"},{"location":"tutorials/#paso-3-definimos-la-funcion-que-retornara-el-metodo-de-jacobi","title":"Paso 3: Definimos la funci\u00f3n que retornara el m\u00e9todo de Jacobi","text":"<pre><code>def jacobi_relaxation(L, M, V_p, V_n, tolerance):\n    # Primero creamos los arreglos 2-dimensionales de la grilla\n    # Vamos a necesitar dos seg\u00fan la regla de Jacobi\n    # Note que usamos M+1, debido a que debemos contener la condici\u00f3n de frontera\n    # phi contiene inicialmente los valores iniciales. Vamos a utilizar ceros.\n    phi = np.zeros((M + 1, M + 1), dtype=float)\n\n    # --- Calculamos la reposici\u00f3n dependiendo del valor de M\n    fil_start = int((2 * M) / L) # 2 cm desde arriba\n    vol_len = int((6 * M) / L)   # 6 cm longitud de la barra\n    fil_end = fil_start + vol_len\n\n    col_plus = int((2 * M) / L)  # voltaje positivo a 2 cm del borde izquierdo\n    col_neg = col_plus + vol_len # Voltaje negativo a 2 cm del borde derecho\n\n    # Ahora tenemos que colocar la condici\u00f3n inicial.\n    # Recuerde accesos de listas en np.ndarray\n    phi[fil_start:fil_end, col_plus] = V_p\n    phi[fil_start:fil_end, col_neg] = V_n\n    # phiprime se necesita para la iteraci\u00f3n\n    phiprime = np.zeros((M + 1, M + 1), dtype=float)\n    # Iteraci\u00f3n de Jacobi\n    delta = 1.0\n    its = 0\n    while delta &gt; tolerance:\n        # Calculamos la iteraci\u00f3n\n        its += 1\n        for i in range(M + 1):\n            for j in range(M + 1):\n                if j == col_plus and fil_start &lt;= i &lt;= fil_end or j == col_neg and fil_start &lt;= i &lt;= fil_end:\n                    phiprime[i, j] = phi[i, j]\n                # Condici\u00f3n de frontera\n                elif i == 0 or i == M or j == 0 or j == M:\n                    phiprime[i, j] = phi[i, j]\n                # Iteraci\u00f3n principal\n                else:\n                # COMPLETE AQU\u00cd\n                    phiprime[i,j] = 0.25 * (phi[i + 1, j] + phi[i - 1, j] + phi[i, j + 1] + phi[i, j - 1])\n        # Calculamos la diferencia m\u00e1xima con respecto a los valores anteriores\n        delta = np.max(np.abs(phi - phiprime))\n        # Ahora intercambiamos los arreglos para la nueva iteraci\u00f3n\n        # El nuevo phi es el phiprime\n        temp = phi\n        phi = phiprime\n        # El nuevo phiprime es el phi viejo\n        phiprime = temp\n    return phi, its, delta\n</code></pre>"},{"location":"tutorials/#paso-4-llamado-a-la-funcion","title":"Paso 4: Llamado a la funci\u00f3n","text":"<p>En esta parte escribimos el llamado a la funci\u00f3n para almacenar los resultados en nuevas variables y poder realizar la impresi\u00f3n en pantalla</p> <pre><code>jacobi_vals, iterations, error = jacobi_relaxation(10, 100, 1.0, -1.0, 1e-5)\nprint(f\"Convergencia alcanzada en {iterations} iteraciones con error {error:.2e}\")\n</code></pre>"},{"location":"tutorials/#paso-5-ejecutamos-el-codigo","title":"Paso 5: Ejecutamos el c\u00f3digo","text":"<p>guardamos el archivo de jacobi.py y lo ejecutamos - primero a\u00f1adimos permisos de ejecuci\u00f3n: <pre><code>chmod +x jacobi.py\n</code></pre> - Segundo ejecutamos el c\u00f3digo <pre><code>./jacobi.py\n</code></pre></p>"},{"location":"tutorials/#paso-6-graficar","title":"Paso 6: Graficar","text":"<p>Escribimos el c\u00f3digo a utilizar para realizar la gr\u00e1fica esperada</p> <pre><code>plt.imshow(jacobi_vals, cmap='jet')  # Aplicar colormap expl\u00edcitamente\nplt.colorbar(label='Potencial el\u00e9ctrico')  # A\u00f1adir barra de color con etiqueta\nplt.title('Distribuci\u00f3n de potencial - M\u00e9todo de relajaci\u00f3n de Jacobi')\nplt.savefig('Jacobi.png', dpi=300)  # Guarda la imagen con buena resoluci\u00f3n\nplt.show()\n</code></pre>"},{"location":"tutorials/#grafica","title":"Gr\u00e1fica:","text":""}]}