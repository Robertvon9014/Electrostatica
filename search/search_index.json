{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/","title":"Referencias","text":""},{"location":"reference/#metodo-de-relajacion-de-jacobi","title":"M\u00e9todo de relajaci\u00f3n de Jacobi","text":""},{"location":"reference/#src.jaccobi.jacobi_relaxation","title":"<code>jacobi_relaxation(L, M, V_p, V_n, tolerance)</code>","text":"<p>Resuelve el potencial el\u00e9ctrico en una placa cuadrada usando el m\u00e9todo de relajaci\u00f3n de Jacobi.</p> <p>Se modela la regi\u00f3n cuadrada de tama\u00f1o <code>L x L</code>dividida en <code>M x M</code> puntos. Se tienen dos barras verticales que se colocan como condiciones de frontera internas: Una posee un potencial <code>V_p</code> y otra con <code>V_n</code>. La funci\u00f3n itera hasta que el cambio m\u00e1ximo entre iteraciones sea menor que la <code>tolerance</code>.</p> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>Tama\u00f1o f\u00edsico de la placa cuadrada (dado en cm).</p> required <code>M</code> <code>int</code> <p>N\u00famero de divisiones de la grilla (grilla de (M+1) x (M+1)).</p> required <code>V_p</code> <code>float</code> <p>Voltaje aplicado en la barra positiva.</p> required <code>V_n</code> <code>float</code> <p>Voltaje aplicado en la barra negativa.</p> required <code>tolerance</code> <code>float</code> <p>Tolerancia para el criterio de convergencia.</p> required <p>Returns:</p> Name Type Description <code>phi</code> <code>ndarray</code> <p>Matriz de 2 dimensiones con potenciales verticales dados por dos barras.</p> <code>its</code> <code>int</code> <p>N\u00famero de iteraciones realizadas.</p> <code>delta</code> <code>float</code> <p>Error m\u00e1ximo alcanzado en la \u00faltima iteraci\u00f3n.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; phi, its, error = jacobi_relaxation(10, 100, 1.0, -1.0, 1e-5)\n&gt;&gt;&gt; print(f\"Iteraciones: {its}, Error final: {error:.2e}\")\nIteraciones: 1794, Error final: 9.99e-06\n</code></pre> Source code in <code>src/jaccobi.py</code> <pre><code>def jacobi_relaxation(L, M, V_p, V_n, tolerance):\n    \"\"\"\n    Resuelve el potencial el\u00e9ctrico en una placa cuadrada usando el m\u00e9todo de relajaci\u00f3n de Jacobi.\n\n    Se modela la regi\u00f3n cuadrada de tama\u00f1o `L x L`dividida en `M x M` puntos.\n    Se tienen dos barras verticales que se colocan como condiciones de frontera internas:\n    Una posee un potencial `V_p` y otra con `V_n`. La funci\u00f3n itera hasta que el cambio\n    m\u00e1ximo entre iteraciones sea menor que la `tolerance`.\n\n    Args:\n        L (int): Tama\u00f1o f\u00edsico de la placa cuadrada (dado en cm).\n        M (int): N\u00famero de divisiones de la grilla (grilla de (M+1) x (M+1)).\n        V_p (float): Voltaje aplicado en la barra positiva.\n        V_n (float): Voltaje aplicado en la barra negativa.\n        tolerance (float): Tolerancia para el criterio de convergencia.\n\n    Returns:\n        phi (ndarray): Matriz de 2 dimensiones con potenciales verticales dados por dos barras.\n        its (int): N\u00famero de iteraciones realizadas.\n        delta (float): Error m\u00e1ximo alcanzado en la \u00faltima iteraci\u00f3n.\n\n    Examples:\n        &gt;&gt;&gt; phi, its, error = jacobi_relaxation(10, 100, 1.0, -1.0, 1e-5)\n        &gt;&gt;&gt; print(f\"Iteraciones: {its}, Error final: {error:.2e}\")\n        Iteraciones: 1794, Error final: 9.99e-06\n    \"\"\"\n    # Primero creamos los arreglos 2-dimensionales de la grilla\n    # Vamos a necesitar dos seg\u00fan la regla de Jacobi\n    # Note que usamos M+1, debido a que debemos contener la condici\u00f3n de frontera\n    # phi contiene inicialmente los valores iniciales. Vamos a utilizar ceros.\n    phi = np.zeros((M + 1, M + 1), dtype=float)\n    # Ahora tenemos que colocar la condici\u00f3n inicial.\n    # Recuerde accesos de listas en np.ndarray\n\n    # --- Calculamos la reposici\u00f3n dependiendo el tama\u00f1o de M\n    fil_start = int((2 * M) / L) # 2 cm desde arriba\n    bar_len = int((6 * M) / L)   # 6 cm longitud de la barra\n    fil_end = fil_start + bar_len\n\n    col_plus = int((2 * M) / L)  # Voltaje positivo a 2 cm del borde izquierdo\n    col_neg = col_plus + bar_len # Voltaje Negativo a 2 cm del borde derecho\n\n    # Ahora tenemos que colocar la condici\u00f3n inicial.\n    # Recuerde accesos de listas en np.ndarray\n    phi[fil_start:fil_end, col_plus] = V_p  # Barra positiva\n    phi[fil_start:fil_end, col_neg] = V_n    # Barra negativa\n\n    # phiprime se necesita para la iteraci\u00f3n\n    phiprime = np.zeros((M + 1, M + 1), dtype=float)\n    # Iteraci\u00f3n de Jacobi\n    delta = 1.0\n    its = 0\n    while delta &gt; tolerance:\n        # Calculamos la iteraci\u00f3n\n        its += 1\n        for i in range(M + 1):\n            for j in range(M + 1):\n                # Condici\u00f3n de frontera\n                if j == col_plus and fil_start &lt;= i &lt;= fil_end or j == col_neg and fil_start &lt;= i &lt;= fil_end:\n                    phiprime[i, j] = phi[i,j]\n                elif i == 0 or i == M or j == 0 or j == M:\n                    phiprime[i, j] = phi[i, j]\n                # Iteraci\u00f3n principal\n                else:\n                # COMPLETE AQU\u00cd\n                    phiprime[i,j] = 0.25 * (phi[i + 1, j] + phi[i - 1, j] + phi[i, j + 1] + phi[i, j - 1])\n        # Calculamos la diferencia m\u00e1xima con respecto a los valores anteriores\n        delta = np.max(np.abs(phi - phiprime))\n        # Ahora intercambiamos los arreglos para la nueva iteraci\u00f3n\n        # El nuevo phi es el phiprime\n        temp = phi\n        phi = phiprime\n        # El nuevo phiprime es el phi viejo\n        phiprime = temp\n\n    return phi, its, delta\n</code></pre>"},{"location":"reference/#metodo-de-sobre-relajacion-de-jacobi","title":"M\u00e9todo de Sobre-relajaci\u00f3n de Jacobi","text":""},{"location":"reference/#src.jaccobi_modified.jacobi_modified","title":"<code>jacobi_modified(L, M, V_p, V_n, omega, tolerance)</code>","text":"<p>Aplicamos el m\u00e9todo de Jacobi modificado con sobre-relajaci\u00f3n para resolver el potencial el\u00e9ctrico en una placa cuadrada con condiciones de frontera internas.</p> <p>Se modela la regi\u00f3n cuadrada de tama\u00f1o <code>L x L</code>dividida en <code>M x M</code> puntos. Se tienen dos barras verticales que se colocan como condiciones de frontera internas: Una posee un potencial <code>V_p</code> y otra con <code>V_n</code>. Se actualiza iterativamente el potencial en el resto de la grilla usando un factor de sobre-relajaci\u00f3n <code>omega</code> para acelerar la convergencia.</p> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>Tama\u00f1o f\u00edsico de la placa cuadrada (dado en cm).</p> required <code>M</code> <code>int</code> <p>N\u00famero de divisiones de la grilla (grilla de (M+1) x (M+1)).</p> required <code>V_p</code> <code>float</code> <p>Voltaje aplicado en la barra positiva.</p> required <code>V_n</code> <code>float</code> <p>Voltaje aplicado en la barra negativa.</p> required <code>tolerance</code> <code>float</code> <p>Tolerancia para el criterio de convergencia.</p> required <p>Returns:</p> Name Type Description <code>phi</code> <code>ndarray</code> <p>Matriz de 2 dimensiones con potenciales verticales dados por dos barras.</p> <code>its</code> <code>int</code> <p>N\u00famero de iteraciones realizadas.</p> <code>delta</code> <code>float</code> <p>Error m\u00e1ximo alcanzado en la \u00faltima iteraci\u00f3n.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; phi, its, error = jacobi_modified(10, 100, 1.0, -1.0, 1e-5)\n&gt;&gt;&gt; print(f\"Iteraciones: {its}, Error final: {error:.2e}\")\nerror en la iteraci\u00f3n.\n</code></pre> Source code in <code>src/jaccobi_modified.py</code> <pre><code>def jacobi_modified(L, M, V_p, V_n, omega, tolerance):\n    \"\"\"\n    Aplicamos el m\u00e9todo de Jacobi modificado con sobre-relajaci\u00f3n para resolver\n    el potencial el\u00e9ctrico en una placa cuadrada con condiciones de frontera internas.\n\n    Se modela la regi\u00f3n cuadrada de tama\u00f1o `L x L`dividida en `M x M` puntos.\n    Se tienen dos barras verticales que se colocan como condiciones de frontera internas:\n    Una posee un potencial `V_p` y otra con `V_n`. Se actualiza iterativamente el potencial\n    en el resto de la grilla usando un factor de sobre-relajaci\u00f3n `omega` para acelerar la convergencia.\n\n    Args:\n        L (int): Tama\u00f1o f\u00edsico de la placa cuadrada (dado en cm).\n        M (int): N\u00famero de divisiones de la grilla (grilla de (M+1) x (M+1)).\n        V_p (float): Voltaje aplicado en la barra positiva.\n        V_n (float): Voltaje aplicado en la barra negativa.\n        tolerance (float): Tolerancia para el criterio de convergencia.\n\n    Returns:\n        phi (ndarray): Matriz de 2 dimensiones con potenciales verticales dados por dos barras.\n        its (int): N\u00famero de iteraciones realizadas.\n        delta (float): Error m\u00e1ximo alcanzado en la \u00faltima iteraci\u00f3n.\n\n    Examples:\n        &gt;&gt;&gt; phi, its, error = jacobi_modified(10, 100, 1.0, -1.0, 1e-5)\n        &gt;&gt;&gt; print(f\"Iteraciones: {its}, Error final: {error:.2e}\")\n        error en la iteraci\u00f3n.\n    \"\"\"\n    # Primero creamos los arreglos 2-dimensionales de la grilla\n    # Vamos a necesitar dos seg\u00fan la regla de Jacobi\n    # Note que usamos M+1, debido a que debemos contener la condici\u00f3n de frontera\n    # phi contiene inicialmente los valores iniciales. Vamos a utilizar ceros.\n    phi = np.zeros((M + 1, M + 1), dtype=float)\n\n    # --- Calculamos la reposici\u00f3n dependiendo del valor de M\n    fil_start = int((2 * M) / L) # 2 cm desde arriba\n    vol_len = int((6 * M) / L)   # 6 cm longitud de la barra\n    fil_end = fil_start + vol_len\n\n    col_plus = int((2 * M) / L)  # voltaje positivo a 2 cm del borde izquierdo\n    col_neg = col_plus + vol_len # Voltaje negativo a 2 cm del borde derecho\n\n    # Ahora tenemos que colocar la condici\u00f3n inicial.\n    # Recuerde accesos de listas en np.ndarray\n    phi[fil_start:fil_end, col_plus] = V_p\n    phi[fil_start:fil_end, col_neg] = V_n\n    # phiprime se necesita para la iteraci\u00f3n\n    phiprime = np.zeros((M + 1, M + 1), dtype=float)\n    # Iteraci\u00f3n de Jacobi\n    delta = 1.0\n    its = 0\n    while delta &gt; tolerance:\n        # Calculamos la iteraci\u00f3n\n        its += 1\n        for i in range(M + 1):\n            for j in range(M + 1):\n                if j == col_plus and fil_start &lt;= i &lt;= fil_end or j == col_neg and fil_start &lt;= i &lt;= fil_end:\n                    phiprime[i, j] = phi[i, j]\n                # Condici\u00f3n de frontera\n                elif i == 0 or i == M or j == 0 or j == M:\n                    phiprime[i, j] = phi[i, j]\n                # Iteraci\u00f3n principal\n                else:\n                # COMPLETE AQU\u00cd\n                    phiprime[i,j] = (1 + omega) * (0.25 * (phi[i + 1, j] + phi[i - 1, j] + phi[i, j + 1] + phi[i, j - 1])) - (omega * phi[i,j])\n        # Calculamos la diferencia m\u00e1xima con respecto a los valores anteriores\n        delta = np.max(np.abs(phi - phiprime))\n        # Ahora intercambiamos los arreglos para la nueva iteraci\u00f3n\n        # El nuevo phi es el phiprime\n        temp = phi\n        phi = phiprime\n        # El nuevo phiprime es el phi viejo\n        phiprime = temp\n    return phi, its, delta\n</code></pre>"},{"location":"reference/#metodo-de-gauss-seidel","title":"M\u00e9todo de Gauss-seidel","text":""},{"location":"reference/#src.gauss_seidel.gauss_seidel","title":"<code>gauss_seidel(L, M, V_p, V_n, tolerance)</code>","text":"<p>Resuelve el potencial el\u00e9ctrico en una placa cuadrada usando el m\u00e9todo de Gauss-seidel.</p> <p>Se modela la regi\u00f3n cuadrada de tama\u00f1o <code>L x L</code>dividida en <code>M x M</code> puntos. Se tienen dos barras verticales que se colocan como condiciones de frontera internas: Una posee un potencial <code>V_p</code> y otra con <code>V_n</code>. La funci\u00f3n itera hasta que el cambio m\u00e1ximo entre iteraciones sea menor que la <code>tolerance</code>.</p> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>Tama\u00f1o f\u00edsico de la placa cuadrada (dado en cm).</p> required <code>M</code> <code>int</code> <p>N\u00famero de divisiones de la grilla (grilla de (M+1) x (M+1)).</p> required <code>V_p</code> <code>float</code> <p>Voltaje aplicado en la barra positiva.</p> required <code>V_n</code> <code>float</code> <p>Voltaje aplicado en la barra negativa.</p> required <code>tolerance</code> <code>float</code> <p>Tolerancia para el criterio de convergencia.</p> required <p>Returns:</p> Name Type Description <code>phi</code> <code>ndarray</code> <p>Matriz de 2 dimensiones con potenciales verticales dados por dos barras.</p> <code>its</code> <code>int</code> <p>N\u00famero de iteraciones realizadas.</p> <code>delta</code> <code>float</code> <p>Error m\u00e1ximo alcanzado en la \u00faltima iteraci\u00f3n.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; phi, its, error = jacobi_relaxation(10, 100, 1.0, -1.0, 1e-5)\n&gt;&gt;&gt; print(f\"Convergencia alcanzada en {itertions} iteraciones con error de {error:.2e}\")\nConvergencia alcanzada en 1125 iteraciones con error de 9.97e-06\n</code></pre> Source code in <code>src/gauss_seidel.py</code> <pre><code>def gauss_seidel(L, M, V_p, V_n, tolerance):\n    \"\"\"\n    Resuelve el potencial el\u00e9ctrico en una placa cuadrada usando el m\u00e9todo de Gauss-seidel.\n\n    Se modela la regi\u00f3n cuadrada de tama\u00f1o `L x L`dividida en `M x M` puntos.\n    Se tienen dos barras verticales que se colocan como condiciones de frontera internas:\n    Una posee un potencial `V_p` y otra con `V_n`. La funci\u00f3n itera hasta que el cambio\n    m\u00e1ximo entre iteraciones sea menor que la `tolerance`.\n\n    Args:\n        L (int): Tama\u00f1o f\u00edsico de la placa cuadrada (dado en cm).\n        M (int): N\u00famero de divisiones de la grilla (grilla de (M+1) x (M+1)).\n        V_p (float): Voltaje aplicado en la barra positiva.\n        V_n (float): Voltaje aplicado en la barra negativa.\n        tolerance (float): Tolerancia para el criterio de convergencia.\n\n    Returns:\n        phi (ndarray): Matriz de 2 dimensiones con potenciales verticales dados por dos barras.\n        its (int): N\u00famero de iteraciones realizadas.\n        delta (float): Error m\u00e1ximo alcanzado en la \u00faltima iteraci\u00f3n.\n\n    Examples:\n        &gt;&gt;&gt; phi, its, error = jacobi_relaxation(10, 100, 1.0, -1.0, 1e-5)\n        &gt;&gt;&gt; print(f\"Convergencia alcanzada en {itertions} iteraciones con error de {error:.2e}\")\n        Convergencia alcanzada en 1125 iteraciones con error de 9.97e-06\n    \"\"\"\n    # Primero creamos el arreglo 2-dimensionales de la grilla\n    # Note que usamos M+1, debido a que debemos contener la condici\u00f3n de frontera\n    # phi contiene inicialmente los valores iniciales. Vamos a utilizar ceros.\n    phi = np.zeros((M + 1, M + 1), dtype=float)\n\n    # --- Calculamos la reposici\u00f3n dependiendo del valor de M\n    fil_start = int((2 * M) / L) # 2 cm desde arriba\n    vol_len = int((6 * M) / L)   # 6 cm longitud de la barra\n    fil_end = fil_start + vol_len\n\n    col_plus = int((2 * M) / L)  # voltaje positivo a 2 cm del borde izquierdo\n    col_neg = col_plus + vol_len # Voltaje negativo a 2 cm del borde derecho\n\n    # Ahora tenemos que colocar la condici\u00f3n inicial.\n    # Recuerde accesos de listas en np.ndarray\n    phi[fil_start:fil_end, col_plus] = V_p\n    phi[fil_start:fil_end, col_neg] = V_n\n    # Vamos a guardar una copia para evaluar el error\n    phi_copy = phi.copy()\n    # Iteraci\u00f3n de Gauss-Seidel\n    delta = 1.0\n    its = 0\n    while delta &gt; tolerance:\n        # Calculamos la iteraci\u00f3n\n        its += 1\n        for i in range(1, M):\n            for j in range(1, M):\n                # Condici\u00f3n de frontera\n                # En este caso, en la frontera los valores no se modifican\n                if fil_start &lt;= i &lt;= fil_end and (j == col_plus or j == col_neg):\n                    continue\n                # Iteraci\u00f3n principal\n                else:\n                    # COMPLETE AQU\u00cd\n                    phi[i,j] = 0.25 * (phi[i + 1, j] + phi[i - 1, j] + phi[i, j + 1] + phi[i, j - 1] )\n        # Calculamos la diferencia m\u00e1xima con respecto a los valores anteriores\n        delta = np.max(np.abs(phi - phi_copy))\n        # Copiamos los valores de la nueva iteraci\u00f3n\n        phi_copy = phi.copy()\n\n    return phi, its, delta\n</code></pre>"},{"location":"reference/#metodo-de-gauss-seidel-implementado-en-c","title":"M\u00e9todo de Gauss-seidel implementado en c++","text":""}]}